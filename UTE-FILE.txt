DRAFT

This file describes storage concepts of uterus.

Uterus provides efficient tick data storage and is primarily considered
a file format (or codec) rather than a tool box of algorithms.  The
meticulous storage layout specifications are necessary to help the
algorithms perform in a nearly optimal way.

Uterus data structures are layered.  Here is a list from primitve to
complex layers:
* tick payloads
* ticks
* tick pages
* tick file

Following the data-metadata separation approach any of the above is
usually accompanied by meta data that aids administrative and
algorithmic tasks such as sorting, searching, slabbing, grouping, etc.

The overall design (and any of the layers in particular) is chunk based,
so that new/old chunks can be overlooked by older/newer versions of the
codec (backward/forward compatibility).  Metadata is usually
sufficiently annotated so that the back/forth compatibility paradigm
is still fulfilled.


Tick payloads
=============
Tick payloads are usually 32 bits wide, under certain circumstances 64
bits are admissible too.  Tick payloads always come in multiples of 64
bits, so 32bit payloads come in pairs.

The meaning (and context) of the payload depends on the surrounding tick
type and hence tick payloads cannot exist on their own.

1. m30 payloads (32 bits)
Prices, the most important data to track, can be encoded using a special
fixed-point format with 30 mantissa bits and 2 exponent bits.

Exponents are
- 0x00 1E-8
- 0x01 1E-4
- 0x02 1E+0
- 0x03 1E+4

That means there is no unique nor canonical presentation for a given
decimal number.  Also note, in contrast to ieee754 there is no sign bit
so signedness interpretation is up to the application.

This gives following ranges:
- 0x00 0.00000000 to 5.36870912
- 0x01 0.0000 to 53687.0912
- 0x02 0 to 538670912
- 0x03 0, then 10000 to 5368709120000

2. m62 payloads (64 bits)
The wider version of m30 data is m62 data which uses 62 mantissa bits
and 2 exponent bits. 

The exponents are the same as the m30 ones.  This gives following
ranges:
- 0x00 0.00000000 to 23058430092.13693952
- 0x01 0.0000 to 230584300921369.3952
- 0x02 0 to 2305843009213693952
- 0x03 0, then 10000 to 23058430092136939520000

3. u32 payloads

This is indeed the (anonymous) type used to implement tick payloads, a
plain uint32_t that is capable of storing 32bits.

4. u64 payloads

This is indeed the (anonymous) type used to implement tick payloads, a
plain uint64_t that is capable of storing 64bits.

Supported routines:
Conversion to m30:
m30_t get_ui32(uint32_t);
m30_t get_f(float);
m30_t get_d(double);
m30_t get_s(const char**);

Conversion from m30:
uint32_t ui32(m30_t);
float f(m30_t);
double d(m30_t);
size_t s(char*, m30_t);

Conversion to m62:
m62_t get_ui64(uint64_t);
m62_t get_f(float);
m62_t get_d(double);
m62_t get_s(const char**);

Conversion from m62:
uint64_t ui64(m62_t);
float f(m62_t);
double d(m62_t);
size_t s(char*, m62_t);

BEWARE: uterus does not provide arithmetics for m30 and m62 numbers!


Ticks
=====
Ticks are the envelopes of tick payloads in the sense that they give
them their meanings.  The tick layer is flexible and extensible apart
from the tick header which will not change in future versions due to its
importance.

Header:
-------
The header consists of following data (and widths)
offset   width   slot  description
0x0000   32bits  sec   unix timestamp of the tick
0x0004   10bits  msec  millisecond part of the timestamp
0x000x    6bits  ttf   tick type and flags
0x0007   16bits  idx   index, used to distinguish several time series
0x0008   var.          tick payloads

These constraints imply:
- there cannot be ticks on 01 Jan 1970 00:00:00, special stamp 0x00000000
- there cannot be ticks on 31 Dec 1969 23:59:59, special stamp 0xffffffff
- the oldest tick date is: dd mmm 1902, special stamp 0x80000000
- the youngest tick date is: dd mmm 2038, special, stamp 0x7fffffff
- tick msec values must be between 000 and 999 otherwise they change the
  meaning of the tick
- there can be only 256 simultaneous time series (idx is 8bits)

There is some predefined functionality overloading the msec slot.
A value of:
- 1023 indicates that the tick in question does not exist.
- 1022 is reserved for unserding, meaning the tick is on hold.
- 1021 indicates a market-halted event tick
- 1020 indicates a padding tick which is used for alignment in tick
       pages/files, the tick must be ignored altogether
- 1019 indicates that the tick is a once-a-day tick, i.e. the
       hour/minute/second part of the time stamp is to be ignored
- 1000 indicates that a millisecond resolution of the timestamp is not
       available for the tick in question

Moreover, there are some predefined values for the ttf slot:
value   name   indicates
0x0000  unk    an unknown tick type
0x0001  bid    speaks for itself
0x0002  ask    speaks for itself
0x0003  tra    a trade tick
0x0004  fix    a fixing tick
0x0005  stl    a settlement tick
0x0006  auc    an auction tick
0x0007  div    a dividend tick
0x0008  vol    a (pure) volume tick (uses m62 payloads)
0x0009  vpr    a price volume tick (uses m62 payloads)
0x000a  vwp    a VWAP tick (vpr divided by vol)
0x000b  spl    a split tick, two m30s denoting before and after
0x000c  oi     an open interest tick (number of all open long contracts)

We now discuss predefined tick types.

Sparse level 1 ticks:
---------------------
Sparsity in this sense means that a tick payload is fully wrapped in a
tick envelope, i.e. a transferred bid/ask or bid/ask/trade tuple is
dissected into 2 or 3 single ticks, each having their own timestamps
(or generally headers).

A sparse level 1 tick looks like:

offset   width   slot   description
0x0000   64bits  hdr    the full header as described above
0x0008   32bits  v1     an m30-coded price (for bid/ask/tra/fix/stl/auc/vwp)
0x000c   32bits  v2     an m30-coded size
0x0010

or
0x0000   64bits  hdr    the full header as described above
0x0008   64bits  w      an m62-coded value (for vol/vpr)
0x0010

Sparse candles:
---------------
Sparsity is to be understood as for sparse level 1 ticks.

A sparse candle looks like:

offset   width   slot   description
0x0000   64bits  hdr    the full header as described above
0x0008   32bits  hi     the high price, m30-coded
0x000c   32bits  lo     the low price, m30-coded
0x0010   32bits  op     the open price, m30-coded
0x0014   32bits  cl     the close price, m30-coded
0x0018   32bits  sts    the time stamp when the candle started
0x001c   32bits  cnt    free, used to count the number of ticks in the
                        interval at the moment
0x0020

Deviating from the standard O/H/L/C notation the layout here has been
optimised so that the more frequently used open and close prices are on
a 128bit boundary (for algorithms using SSE).

Sparse snapshots:
-----------------
A sparse snapshot can be used to reflect a current view on the market,
as if it was freezed.  If freezed a captured security generally has a
bid side, an ask side and some trade history.
The ticks look like:

offset   width   slot   description
0x0000   64bits  hdr    the full header as described above
0x0008   32bits  bq     the m30-coded size of the bid position
0x000c   32bits  aq     the m30-coded size of the ask position
0x0010   32bits  bp     the m30-coded bid price
0x0014   32bits  ap     the m30-coded ask price
0x0018   32bits  tvpr   free, or the m30-coded traded volume price
0x001c   32bits  tq     free, or the m30-coded total traded quantity
0x0020

The layout, again, has been optimised so that the frequently used bid
and ask prices are on a 128bit boundary (for algorithms using SSE).

The last 2 slots are generally free, as snapshots depict the current
market situation and it is rather unlikely that a trade has happened
exactly at the specified time of the tick.

Note however, if the tvpr and tq slots are used, there is currently no
way of keeping track (inside the tick envelope) which period has been
used for their observation, this information has to be built-in
knowledge of the application or has to be stored elsewhere.

Sparse BAT candles:
-------------------
A sparse BAT candle can be used to capture OHLCV candles for the bid,
ask and trade sides altogether, and looks like:

offset   width   slot   description
0x0000   64bits  hdr    the full header as described above
0x0008   32bits  bo     bid-open (m30-coded)
0x000c   32bits  bh     bid-high (m30-coded)
0x0010   32bits  bl     bid-low (m30-coded)
0x0014   32bits  bc     bid-close (m30-coded)
0x0018   32bits  ao     ask-open (m30-coded)
0x001c   32bits  ah     ask-high (m30-coded)
0x0020   32bits  al     ask-low (m30-coded)
0x0024   32bits  ac     ask-close (m30-coded)
0x0028   32bits  to     trade-open (m30-coded)
0x002c   32bits  th     trade-high (m30-coded)
0x0030   32bits  tl     trade-low (m30-coded)
0x0034   32bits  tc     trade-close (m30-coded)
0x0038   32bits  tv     trade volume (m30-coded)
0x003c   32bits  sts    the time stamp when the candle started

This tick type is highly experimental and subject to change.

Dense level1 ticks:
-------------------
Dense level1 ticks can be used for an equidistant time series to keep
track of several tick payloads of different times using just one tick
header, it is dense storage in that sense.

There is no stipulated format for this other than that padding payloads
may have to be inserted to have ticks starting on a 64bit (recommended
is even a 128bit) boundary.  Also be aware that there is (currently) no
way of storing the width of these equidistant steps, it has to be either
built-in knowledge or stored elsewhere in the application.

Sparse level2 ticks (depth):
----------------------------
Sparse level2 ticks are not inherently distinct from sparse level1
ticks, in fact they can be marked as such using 1 bit (WHICH ONE?).
Given the strict ordering by time and the overall sparseness of ute
files, their nature implies minor differences in the way a processor
tool must treat changing quotes, sizes, depths.

In the naive aggregation mode, where for a given price level all
contributing sizes add up to one number, a change in depth can be
represented with one sparse level2 tick, holding a price level and an
(aggregated) size.  If that size is made of two parties and one of them
is about to change their quote, there will be two level2 ticks, one
stating the new size of the former price level, one stating the new
price of the changing party's quote along with its size.

One proposal, ticks along the time axis, cf. Example 1 to 4.

Example 1
---------
We demonstrate how depth is built up.

  L2(09:00:00.000, b, 15.00, 100)
  L2(09:00:00.100, b, 15.01, 100)

The order book at time 09:00:00.100 would then look like:
  b: 15.01/100  15.00/100
     top level  --depth-->

Example 2 (given the order book of Example 1)
---------
We demonstrate how quotes in depth are changed.
  L2(09:00:00.200, b, 15.00, 200)

The order book at time 09:00:00.200 would then look like:
b: 15.01/100  15.00/200
   top level  --depth-->

Example 3 (given the order book of Example 2):
---------
We demonstrate how a price level in depth is split.
  L2l(09:00:00.300, b, 15.00, 100, 14.99, 100)
Here L2l is a linked tick consisting of 2 sparse level2 ticks.

The order book at time 09:00:00.300 would then look like:
b: 15.01/100  15.00/100  14.99/100
   top level  --depth-->

Example 4 (given the order book of Example 3):
---------
We demonstrate how a price level in depth vanishes.
  L2(09:00:00.400, b, 15.00, 0)

The order book at time 09:00:00.400 would then look like:
b: 15.01/100  14.99/100
   top level  --depth-->

Remark on statelessness:
Given that actually observed sizes and prices are submitted (instead of,
say, price/size increments) it is even possible to miss out on some
ticks in a feed of these sparse level2 ticks gracefully.  That is the
next successfully received tick at price x corrects any mistakes made in
the slot for the price level x.


Further ticks:
--------------
Further tick kinds may be desirable but there is currently no
specification for them.  Here is an assortment of questions:
- Level 2 data? Sparse? Dense?
- Pegs (to determine BBOs (best-bid-offer))?
  Store POTs (place of trade) somewhere?


Tick pages
==========
Tick pages are large collections of ticks of the same kind.


Tick file
=========
A tick file gathers several tick pages.

